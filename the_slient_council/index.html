<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì¹¨ë¬µì˜ ì˜íšŒ (The Silent Council) - ìµœì¢… ë³µì› ë° ì•ˆì •í™”</title>
    <style>
        :root {
            --p1-color: #4facfe; /* ì§‘ì •ê´€ */
            --p2-color: #ff0844; /* ì„ ë™ê°€ */
            --neutral-color: #ffd700; /* ì¤‘ë¦½ */
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --border-color: #333;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- Header & Tutorial --- */
        header { width: 100%; padding: 10px 20px; display: flex; justify-content: center; align-items: center; background: var(--panel-bg); border-bottom: 1px solid var(--border-color); position: relative; }
        h1 { margin: 0; font-size: 1.5rem; letter-spacing: 2px; }
        
        #tutorial-btn {
            position: absolute;
            left: 20px;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--neutral-color);
            color: #000;
            font-weight: bold;
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
        }

        /* --- Game Area --- */
        #game-container { display: flex; width: 100%; height: 100%; padding: 20px; box-sizing: border-box; gap: 20px; }
        
        /* Left: Map */
        #left-panel { flex: 2; display: flex; flex-direction: column; gap: 10px; }
        #map-area { 
            flex-grow: 1; 
            background: #222; 
            border-radius: 10px; 
            position: relative; 
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr); 
            gap: 15px; 
            padding: 20px;
        }

        .zone { 
            background: #2a2a2a; 
            border: 2px solid #444; 
            border-radius: 8px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            cursor: pointer; 
            position: relative;
            transition: all 0.2s;
        }
        .zone:hover { background: #333; }
        .zone.selected-source { border-color: #fff; box-shadow: 0 0 15px #fff; animation: pulse 1s infinite; }
        .zone.valid-target { border-color: #0f0; background: #1a331a; }
        .zone.dominated-p1 { border-color: var(--p1-color); box-shadow: 0 0 10px var(--p1-color) inset; }
        .zone.dominated-p2 { border-color: var(--p2-color); box-shadow: 0 0 10px var(--p2-color) inset; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

        .cube-display { font-size: 1.5rem; font-weight: bold; margin: 5px 0; }
        .p1-count { color: var(--p1-color); margin-right: 10px; }
        .p2-count { color: var(--p2-color); }
        .zone-name { font-size: 0.9rem; font-weight: bold; }
        .zone-effect { font-size: 0.7rem; color: var(--neutral-color); text-align: center; border-top: 1px solid #444; padding-top: 5px; margin-top: 5px; width: 80%; }

        /* Right: Controls & Status */
        #right-panel { flex: 1; display: flex; flex-direction: column; gap: 15px; min-width: 320px; }
        
        .status-card { background: var(--panel-bg); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color); }
        
        #stability-track { margin-top: 10px; height: 20px; background: linear-gradient(90deg, var(--p2-color) 0%, #333 50%, var(--p1-color) 100%); position: relative; border-radius: 4px; }
        #stability-marker { position: absolute; top: -5px; width: 4px; height: 30px; background: #fff; border: 1px solid #000; transition: left 0.3s; }
        
        #crisis-track { margin-top: 10px; height: 10px; background: #333; border-radius: 4px; overflow: hidden; }
        #crisis-fill { height: 100%; background: #ff4444; width: 0%; transition: width 0.3s; }

        #hand-area { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; min-height: 150px; }
        .card { 
            width: 90px; height: 130px; 
            background: #333; 
            border: 2px solid #555; 
            border-radius: 6px; 
            padding: 5px; 
            font-size: 0.7rem; 
            cursor: pointer; 
            display: flex; flex-direction: column; justify-content: space-between;
            transition: transform 0.2s;
        }
        .card:hover { transform: scale(1.05); z-index: 10; border-color: #fff; }
        .card.p1 { border-color: var(--p1-color); background: #101820; }
        .card.p2 { border-color: var(--p2-color); background: #201010; }
        .card.neutral { border-color: var(--neutral-color); background: #201e10; }
        .card-title { font-weight: bold; text-align: center; font-size: 0.8rem;}
        .card-op { text-align: center; font-size: 1.1rem; font-weight: bold; background: rgba(0,0,0,0.5); border-radius: 4px; margin: 2px 0;}
        .card-text { font-size: 0.6rem; overflow: hidden; height: 50px; line-height: 1.2; }

        #action-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .btn { padding: 12px; border: none; border-radius: 5px; background: #444; color: white; cursor: pointer; font-weight: bold; }
        .btn:hover:not(:disabled) { background: #666; }
        .btn.active { background: var(--neutral-color); color: black; box-shadow: 0 0 10px var(--neutral-color); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; }

        #log-area { flex-grow: 1; background: #000; border: 1px solid #333; padding: 10px; overflow-y: auto; font-size: 0.8rem; font-family: monospace; color: #ccc; max-height: 150px;}
        .log-p1 { color: var(--p1-color); }
        .log-p2 { color: var(--p2-color); }
        .log-sys { color: var(--neutral-color); }
        .log-warn { color: #ff4444; font-weight: bold; }

        /* --- Tutorials & Modals --- */
        #modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; }
        .modal-box { background: var(--panel-bg); width: 500px; padding: 30px; border-radius: 10px; border: 2px solid var(--neutral-color); text-align: center; position: relative; box-shadow: 0 0 20px #000; }
        .modal-close { position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 1.5rem; color: #888; }
        .tut-nav { display: flex; justify-content: space-between; margin-top: 20px; }
    </style>
</head>
<body>

<header>
    <button id="tutorial-btn" onclick="openTutorial()">?</button>
    <h1>THE SILENT COUNCIL</h1>
</header>

<div id="game-container">
    <div id="left-panel">
        <div id="map-area">
            </div>
        <div id="log-area">
            <div>ì‹œìŠ¤í…œ ê°€ë™... ì•„í¬(Ark) ì ‘ì† ì™„ë£Œ.</div>
        </div>
    </div>

    <div id="right-panel">
        <div class="status-card">
            <div style="display:flex; justify-content:space-between;">
                <span>Round: <span id="round-val">1</span>/6</span>
                <span id="turn-val" style="color:var(--p1-color)">ì§‘ì •ê´€(P1) í„´</span>
            </div>
            <div style="margin-top:10px;">
                ì•ˆì •ë„ (Stability): <span id="stab-val">0</span>
                <div id="stability-track"><div id="stability-marker" style="left:50%"></div></div>
            </div>
            <div style="margin-top:10px;">
                ìœ„ê¸° (Crisis): <span id="crisis-val">0</span>/5
                <div id="crisis-track"><div id="crisis-fill"></div></div>
            </div>
        </div>

        <div class="status-card">
            <div style="margin-bottom:5px;">ë³´ìœ  ì¹´ë“œ (ë‚¨ì€ í–‰ë™: <span id="actions-val">6</span>)</div>
            <div id="hand-area">
                </div>
        </div>

        <div class="status-card">
            <div style="margin-bottom:5px;">ì‘ì „ (í˜„ì¬ OP: <span id="op-val" style="color:var(--neutral-color)">0</span>)</div>
            <div id="action-buttons">
                <button class="btn" id="btn-deploy" onclick="setOpMode('deploy')">ë°°ì¹˜ (1)</button>
                <button class="btn" id="btn-remove" onclick="setOpMode('remove')">ì œê±° (2)</button>
                <button class="btn" id="btn-move" onclick="setOpMode('move_start')">ì´ë™ (1)</button>
                <button class="btn" id="btn-crisis" onclick="doCrisisReduction()">ì¬ì •ë¹„ (2)</button>
            </div>
            <button class="btn" id="btn-pass" style="width:100%; margin-top:10px; background:#553333;" onclick="passTurn()">í„´ ì¢…ë£Œ (ë‚¨ì€ OP í¬ê¸°)</button>
        </div>
    </div>
</div>

<div id="modal-overlay">
    <div class="modal-box">
        <span class="modal-close" onclick="closeModal()">&times;</span>
        <h2 id="tut-title">ê²Œì„ ëª©í‘œ</h2>
        <div id="tut-content" style="min-height: 120px; text-align: left; line-height: 1.6; font-size: 0.95rem; color:#ddd;"></div>
        <div class="tut-nav">
            <button class="btn" onclick="prevTut()">ì´ì „</button>
            <span id="tut-page" style="line-height: 40px;">1 / 5</span>
            <button class="btn" onclick="nextTut()">ë‹¤ìŒ</button>
        </div>
    </div>
</div>

<script>
/** * --- DATA & CONFIG --- 
 */
const ZONES = [
    { id: 0, name: "í–‰ì •", opVal: 1, adj: [1, 2, 6], desc: "ì¥ì•…: ì¸ì ‘ ë¬´ë£Œ ë°°ì¹˜" },
    { id: 1, name: "ì–¸ë¡ ", opVal: 2, adj: [0, 3, 4], desc: "ì¥ì•…: ìƒëŒ€ ì¹´ë“œ ìœ„ê¸° ë¬´íš¨" },
    { id: 2, name: "êµ°ì‚¬", opVal: 3, adj: [0, 5],    desc: "ì¥ì•…: ë¼ìš´ë“œ ë ì¸ì ‘ ì œê±°" },
    { id: 3, name: "ìƒì—…", opVal: 1, adj: [1, 6, 4], desc: "ì¥ì•…: ì¤‘ë¦½ ì¹´ë“œ íšŒìˆ˜" }, 
    { id: 4, name: "ë¹ˆë¯¼", opVal: 2, adj: [1, 3, 5], desc: "ì¥ì•…: ì œê±° ë¹„ìš© ê°ì†Œ" },
    { id: 5, name: "ê³µì—…", opVal: 3, adj: [2, 4, 6], desc: "ì¥ì•…: ì œê±° ë©´ì—­" },
    { id: 6, name: "ì—°êµ¬", opVal: 2, adj: [0, 3, 5], desc: "ì¥ì•…: ë± ì •ë³´ í™•ì¸" }
];

const CARDS_DB = [
    { name: "ê¸´ê¸‰ í†µí–‰ ì œí•œ", op: 1, crisis: 0, type: 'P1', text: "[êµ°ì‚¬] íë¸Œ 2ê°œ ë°°ì¹˜ / ìƒëŒ€ íë¸Œ 1ê°œ ì œê±°" },
    { name: "ì—¬ë¡  í†µì œ", op: 2, crisis: 1, type: 'P1', text: "ìƒëŒ€ ì†íŒ¨ ë²„ë¦¼ / [ì–¸ë¡ ] ìƒëŒ€ íë¸Œ 1ê°œ ë°°ì¹˜" },
    { name: "ì •ì¹˜ ìê¸ˆ", op: 3, crisis: 0, type: 'P1', text: "ì•ˆì •ë„ +1 / ìì‹  íë¸Œ 1ê°œ ì œê±°" },
    { name: "ì‹œë¯¼ ì €í•­", op: 1, crisis: 1, type: 'P2', text: "[ë¹ˆë¯¼] íë¸Œ 2ê°œ ë°°ì¹˜ / [í–‰ì •] ìƒëŒ€ íë¸Œ 1ê°œ ë°°ì¹˜" },
    { name: "ì´íŒŒì—…", op: 3, crisis: 1, type: 'P2', text: "ì•ˆì •ë„ -1 / [ê³µì—…] ìƒëŒ€ íë¸Œ 1ê°œ ë°°ì¹˜" },
    { name: "í•´í‚¹", op: 2, crisis: 0, type: 'P2', text: "[ìƒì—…] ìƒëŒ€ ì œê±° / ìƒëŒ€ ì†íŒ¨ ë± ë°‘ìœ¼ë¡œ" },
    { name: "ìì—°ì¬í•´", op: 1, crisis: 2, type: 'N', text: "ëœë¤ êµ¬ì—­ ì–‘ì¸¡ íë¸Œ 1ê°œì”© ì œê±°" },
    { name: "í•´ì™¸ ì›ì¡°", op: 3, crisis: 0, type: 'N', text: "ì´ë²ˆ í„´ OP +1 ì¶”ê°€" },
    { name: "ê¸´ê¸‰ ì˜ë£Œ", op: 2, crisis: 0, type: 'N', text: "ìœ„ê¸° ìˆ˜ì¹˜ -1" }
];

function createDeck() {
    let d = [];
    for(let i=0; i<4; i++) d = d.concat(JSON.parse(JSON.stringify(CARDS_DB)));
    return d.sort(() => Math.random() - 0.5);
}

/** * --- STATE --- 
 */
let state = {
    round: 1,
    turnPlayer: 1, // 1: P1, -1: P2
    actionsLeft: 6, // ì´ 6ë²ˆì˜ ì¹´ë“œ ì‚¬ìš© ê¸°íšŒ (ìˆ˜ì •: 4 -> 6)
    stability: 0,
    crisis: 0,
    board: [], 
    p1Hand: [],
    p2Hand: [],
    deck: [],
    discard: [],
    currentOP: 0,
    opMode: null, // 'deploy', 'remove', 'move_start', 'move_end'
    moveSourceIdx: null,
    gameOver: false
};

/** * --- INIT & RENDER --- 
 */
function init() {
    state.board = ZONES.map(z => ({ ...z, p1: 0, p2: 0, dom: 0 }));
    state.board[0].p1 = 1; // Initial Setup
    state.board[6].p2 = 1;
    state.deck = createDeck();
    state.discard = [];
    state.stability = 0;
    state.crisis = 0;
    state.round = 1;
    state.gameOver = false;
    
    startRound();
    openTutorial(); 
}

function startRound() {
    if(state.round > 6) return endGame("6ë¼ìš´ë“œ ì¢…ë£Œ. ìµœì¢… ì ìˆ˜ ê³„ì‚°.");
    
    // Draw cards
    if(state.deck.length < 10) {
        state.deck = state.deck.concat(state.discard).sort(() => Math.random() - 0.5);
        state.discard = [];
        log("ë±ì„ ë‹¤ì‹œ ì„ì—ˆìŠµë‹ˆë‹¤.", 'sys');
    }

    // â¬‡ï¸â¬‡ï¸â¬‡ï¸ ìˆ˜ì •ëœ ë“œë¡œìš° ë¡œì§ (í•¸ë“œ ìœ ì§€) â¬‡ï¸â¬‡ï¸â¬‡ï¸
    // P1 ë“œë¡œìš°: 5ì¥ì´ ë  ë•Œê¹Œì§€ë§Œ ë“œë¡œìš°
    const p1DrawCount = 5 - state.p1Hand.length;
    if (p1DrawCount > 0) {
        state.p1Hand = state.p1Hand.concat(state.deck.splice(0, p1DrawCount));
        log(`ì§‘ì •ê´€ ${p1DrawCount}ì¥ ë“œë¡œìš° (ì´ ${state.p1Hand.length}ì¥)`, 'p1');
    }
    // P2 ë“œë¡œìš°: 5ì¥ì´ ë  ë•Œê¹Œì§€ë§Œ ë“œë¡œìš°
    const p2DrawCount = 5 - state.p2Hand.length;
    if (p2DrawCount > 0) {
        state.p2Hand = state.p2Hand.concat(state.deck.splice(0, p2DrawCount));
        log(`ì„ ë™ê°€ ${p2DrawCount}ì¥ ë“œë¡œìš° (ì´ ${state.p2Hand.length}ì¥)`, 'p2');
    }
    // â¬†ï¸â¬†ï¸â¬†ï¸ ìˆ˜ì •ëœ ë“œë¡œìš° ë¡œì§ â¬†ï¸â¬†ï¸â¬†ï¸
    
    // â¬‡ï¸â¬‡ï¸â¬‡ï¸ actionsLeft ì´ˆê¸°ê°’ ë³€ê²½ (4 -> 6) â¬‡ï¸â¬‡ï¸â¬‡ï¸
    state.actionsLeft = 6; 
    // â¬†ï¸â¬†ï¸â¬†ï¸ actionsLeft ì´ˆê¸°ê°’ ë³€ê²½ â¬†ï¸â¬†ï¸â¬†ï¸

    state.turnPlayer = 1; // Round always starts with P1
    state.currentOP = 0;
    state.opMode = null;
    
    updateUI();
    log(`==== ë¼ìš´ë“œ ${state.round} ì‹œì‘: ì§‘ì •ê´€ í„´ ====`, 'sys');
}

function updateUI() {
    // 1. Labels
    document.getElementById('round-val').innerText = state.round;
    document.getElementById('turn-val').innerText = state.turnPlayer === 1 ? "ì§‘ì •ê´€ (P1)" : "ì„ ë™ê°€ (P2)";
    document.getElementById('turn-val').style.color = state.turnPlayer === 1 ? "var(--p1-color)" : "var(--p2-color)";
    document.getElementById('stab-val').innerText = state.stability;
    document.getElementById('crisis-val').innerText = state.crisis;
    document.getElementById('actions-val').innerText = state.actionsLeft;
    document.getElementById('op-val').innerText = state.currentOP;

    // 2. Bars
    const stabPer = 50 + (state.stability * 5); // -10 (0%) to +10 (100%)
    document.getElementById('stability-marker').style.left = `${Math.min(100, Math.max(0, stabPer))}%`;
    document.getElementById('crisis-fill').style.width = `${(state.crisis / 5) * 100}%`;

    // 3. Map
    renderMap();
    // 4. Hand
    renderHand();
    // 5. Buttons
    updateButtons();
}

function renderMap() {
    const container = document.getElementById('map-area');
    container.innerHTML = '';
    
    const gridPos = [
        "1 / 2", "2 / 1", "1 / 3", 
        "3 / 2", "2 / 2", "2 / 3", "3 / 3"
    ];

    state.board.forEach((z, idx) => {
        const el = document.createElement('div');
        el.className = `zone ${z.dom === 1 ? 'dominated-p1' : z.dom === -1 ? 'dominated-p2' : ''}`;
        el.style.gridArea = gridPos[idx];

        // Highlights (Only if P1 turn and has OP)
        if (state.turnPlayer === 1 && state.currentOP > 0) {
            if (state.opMode === 'deploy' && canDeploy(idx, 1)) el.classList.add('valid-target');
            if (state.opMode === 'remove' && canRemove(idx, 1)) el.classList.add('valid-target');
            if (state.opMode === 'move_start' && canMoveStart(idx, 1)) el.classList.add('valid-target');
            if (state.opMode === 'move_end' && canMoveEnd(state.moveSourceIdx, idx)) el.classList.add('valid-target');
        }
        if (state.opMode === 'move_end' && state.moveSourceIdx === idx) el.classList.add('selected-source');

        const dominationEffect = (z.dom !== 0) 
            ? `<div class="zone-effect">${z.dom === 1 ? 'P1 ì¥ì•…' : 'P2 ì¥ì•…'}: ${z.desc}</div>` 
            : `<div class="zone-effect" style="height:1.2em;"></div>`;


        el.innerHTML = `
            <div class="zone-name" style="color:${z.dom===1?'var(--p1-color)':z.dom===-1?'var(--p2-color)':'#fff'}">${z.name} (${z.opVal})</div>
            <div class="cube-display">
                <span class="p1-count">â–  ${z.p1}</span>
                <span class="p2-count">â–  ${z.p2}</span>
            </div>
            ${dominationEffect}
        `;
        el.onclick = () => handleZoneClick(idx);
        container.appendChild(el);
    });
}

function renderHand() {
    const container = document.getElementById('hand-area');
    container.innerHTML = '';
    
    // Show P1 Hand
    if(state.turnPlayer === 1) {
        state.p1Hand.forEach((card, idx) => {
            const el = document.createElement('div');
            el.className = `card ${card.type === 'P1' ? 'p1' : card.type === 'P2' ? 'p2' : 'neutral'}`;
            el.innerHTML = `
                <div class="card-title">${card.name}</div>
                <div class="card-op">${card.op} OP ${card.crisis > 0 ? 'ğŸ”¥'+card.crisis : ''}</div>
                <div class="card-text">${card.text}</div>
            `;
            el.onclick = () => playCard(idx);
            container.appendChild(el);
        });
    } else {
        // Show P2 Hand size
        for(let i=0; i<state.p2Hand.length; i++) {
            const el = document.createElement('div');
            el.className = `card p2`;
            el.style.opacity = 0.5;
            el.style.pointerEvents = 'none';
            el.innerHTML = `<div class="card-title">ì„ ë™ê°€ ì¹´ë“œ</div><div style="text-align:center;">?</div>`;
            container.appendChild(el);
        }
    }
}

function updateButtons() {
    const hasOp = state.currentOP > 0;
    const isP1 = state.turnPlayer === 1;
    const actionsUsed = (6 - state.actionsLeft) > 0;
    
    document.getElementById('btn-deploy').disabled = !isP1 || !hasOp || state.currentOP < 1;
    document.getElementById('btn-remove').disabled = !isP1 || !hasOp || state.currentOP < 2;
    document.getElementById('btn-move').disabled = !isP1 || !hasOp || state.currentOP < 1;
    document.getElementById('btn-crisis').disabled = !isP1 || !hasOp || state.currentOP < 2;
    document.getElementById('btn-pass').disabled = !isP1 || !actionsUsed; // Can't pass if card hasn't been played

    // Reset actives
    ['deploy', 'remove', 'move', 'crisis'].forEach(m => document.getElementById(`btn-${m}`).classList.remove('active'));
    if(state.opMode === 'move_start' || state.opMode === 'move_end') document.getElementById('btn-move').classList.add('active');
    else if(state.opMode) document.getElementById(`btn-${state.opMode}`).classList.add('active');
}

/** * --- GAME ACTIONS --- 
 */

function playCard(idx) {
    if (state.turnPlayer !== 1 || state.actionsLeft <= 0 || state.gameOver) return;
    if (state.currentOP > 0) { alert("ë‚¨ì€ OPë¥¼ ë¨¼ì € ì‚¬ìš©í•˜ê±°ë‚˜ [í„´ ì¢…ë£Œ]ë¥¼ ëˆ„ë¥´ì„¸ìš”."); return; }

    const card = state.p1Hand[idx];
    
    const useOp = confirm(`[${card.name}]\në‚´ìš©: ${card.text}\n\n[í™•ì¸] = ì‘ì „(OP ${card.op})ìœ¼ë¡œ ì‚¬ìš©\n[ì·¨ì†Œ] = ì´ë²¤íŠ¸ë¡œ ì‚¬ìš©`);
    
    if (useOp) {
        // OP Mode
        if (card.type === 'P2') {
            log(`âš  ë”œë ˆë§ˆ! ìƒëŒ€ ì¹´ë“œ(${card.name})ë¥¼ ì‚¬ìš©í•˜ì—¬ OP ${card.op} íšë“. ì„ ë™ê°€ ì´ë²¤íŠ¸ ë°œë™!`, 'warn');
            triggerEventText(card.text, -1);
            state.crisis += card.crisis;
        }
        state.currentOP += card.op;
        log(`OP ${card.op} íšë“. ì‘ì „ì„ ìˆ˜í–‰í•˜ì„¸ìš”.`, 'sys');
    } else {
        // Event Mode (if not P2 card)
        if (card.type === 'P2') { alert("ìƒëŒ€ë°© ì¹´ë“œëŠ” ì´ë²¤íŠ¸ë¡œ ì“¸ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); return; }
        triggerEventText(card.text, 1);
        state.crisis += card.crisis;
        state.currentOP = 0; // Event use immediately ends OP gain phase
    }

    state.p1Hand.splice(idx, 1);
    state.discard.push(card);
    state.actionsLeft--;
    
    checkGameStatus();
    updateUI();
    
    // If card was used as Event (0 OP gained) or a P2 card was used for OP
    if (!useOp || card.type !== 'P1' && card.type !== 'N') {
        // Immediate turn switch if no OP to spend (Event use)
        if (state.currentOP === 0) {
            log("ì´ë²¤íŠ¸ ì‚¬ìš© ì™„ë£Œ. í„´ ì¢…ë£Œ.", 'sys');
            state.turnPlayer = -1;
            updateUI();
            setTimeout(endRoundPhase, 1000); // Check phase logic
        }
    }
}

function triggerEventText(text, player) {
    log(`${player===1?'ì§‘ì •ê´€':'ì„ ë™ê°€'} íš¨ê³¼: ${text}`, player===1?'p1':'p2');
    
    if(text.includes("ì•ˆì •ë„ +1")) state.stability++;
    if(text.includes("ì•ˆì •ë„ -1")) state.stability--;
    if(text.includes("ìœ„ê¸° ìˆ˜ì¹˜ -1")) state.crisis = Math.max(0, state.crisis - 1);
    if(text.includes("OP +1")) state.currentOP++;
    
    const zoneMatch = text.match(/\[(.*?)\]/);
    if(zoneMatch) {
        const zoneName = zoneMatch[1];
        const zone = state.board.find(z => z.name === zoneName);
        if(zone) {
            // Simplified execution of effects
            const targetP = (player===1) ? zone.p1 : zone.p2;
            const oppP = (player===1) ? zone.p2 : zone.p1;

            if(text.includes("íë¸Œ 2ê°œ ë°°ì¹˜")) {
                if(player===1) zone.p1+=2; else zone.p2+=2;
            } else if(text.includes("íë¸Œ 1ê°œ ë°°ì¹˜")) {
                if(player===1) zone.p1++; else zone.p2++;
            } else if(text.includes("ìƒëŒ€ íë¸Œ 1ê°œ ì œê±°") || text.includes("ìƒëŒ€ ì œê±°")) {
                if(player===1) zone.p2 = Math.max(0, zone.p2-1);
                else zone.p1 = Math.max(0, zone.p1-1);
            } else if(text.includes("ìì‹  íë¸Œ 1ê°œ ì œê±°")) {
                if(player===1) zone.p1 = Math.max(0, zone.p1-1);
                else zone.p2 = Math.max(0, zone.p2-1);
            }
            checkDomination(zone);
        }
    }
}

function setOpMode(mode) {
    if(state.currentOP === 0) return alert("OPê°€ ì—†ìŠµë‹ˆë‹¤. ì¹´ë“œë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.");
    state.opMode = mode;
    state.moveSourceIdx = null;
    log(`ì‘ì „ ì„ íƒ: ${mode}`, 'sys');
    updateUI();
}

function doCrisisReduction() {
    if(state.currentOP >= 2) {
        state.currentOP -= 2;
        state.crisis = Math.max(0, state.crisis - 1);
        log("ìœ„ê¸° ìˆ˜ì¹˜ 1 ê°ì†Œ", 'p1');
        updateUI();
    } else {
        alert("ì¬ì •ë¹„ì—ëŠ” 2 OPê°€ í•„ìš”í•©ë‹ˆë‹¤.");
    }
}

function passTurn() {
    const actionsUsed = (6 - state.actionsLeft);
    if(actionsUsed === 0) return; // Must play a card first
    
    if(state.currentOP > 0) {
        log(`ë‚¨ì€ OP (${state.currentOP}) í¬ê¸°`, 'warn');
    }
    
    state.currentOP = 0;
    state.opMode = null;
    state.turnPlayer = -1; // Switch to AI
    
    updateUI();
    setTimeout(endRoundPhase, 1000); // Trigger next phase (AI turn or end round)
}

function handleZoneClick(idx) {
    if(state.turnPlayer !== 1 || state.currentOP === 0) return;
    const zone = state.board[idx];

    let actionTaken = false;

    // DEPLOY
    if(state.opMode === 'deploy' && state.currentOP >= 1 && canDeploy(idx, 1)) {
        state.currentOP--;
        zone.p1++;
        checkDomination(zone);
        log(`${zone.name}ì— ë°°ì¹˜`, 'p1');
        actionTaken = true;
    }
    // REMOVE
    else if(state.opMode === 'remove' && state.currentOP >= 2 && canRemove(idx, 1)) {
        state.currentOP -= 2;
        zone.p2--;
        checkDomination(zone);
        log(`${zone.name}ì—ì„œ ì  ì œê±°`, 'p1');
        actionTaken = true;
    }
    // MOVE START
    else if(state.opMode === 'move_start' && state.currentOP >= 1 && canMoveStart(idx, 1)) {
        state.moveSourceIdx = idx;
        state.opMode = 'move_end';
    }
    // MOVE END
    else if(state.opMode === 'move_end') {
        if(state.currentOP >= 1 && canMoveEnd(state.moveSourceIdx, idx)) {
            state.currentOP--;
            state.board[state.moveSourceIdx].p1--;
            checkDomination(state.board[state.moveSourceIdx]);
            zone.p1++;
            checkDomination(zone);
            log(`${state.board[state.moveSourceIdx].name} -> ${zone.name} ì´ë™`, 'p1');
            actionTaken = true;
        } else {
            // Cancel move selection
            state.opMode = 'move_start';
            state.moveSourceIdx = null;
        }
    }

    if (actionTaken) {
        // After an action, if OP is left, player can choose another action.
        // If OP is 0, reset mode and switch turn.
        if (state.currentOP === 0) {
            state.opMode = null;
            log("OP ì†Œì§„. í„´ ì¢…ë£Œ.", 'sys');
            state.turnPlayer = -1;
            updateUI();
            setTimeout(endRoundPhase, 500); // Check phase logic
        } else {
            // If OP > 0, reset mode to null to force button click for next action
            state.opMode = null; 
        }
    }
    updateUI();
}

// Check Logic
function canDeploy(idx, p) {
    if((p===1?state.board[idx].p1:state.board[idx].p2) > 0) return true;
    for(let adj of state.board[idx].adj) {
        if((p===1?state.board[adj].p1:state.board[adj].p2) > 0) return true;
    }
    return false;
}
function canRemove(idx, p) {
    if(idx === 5 && state.board[idx].dom === (p===1?-1:1)) return false; 
    return (p===1?state.board[idx].p2:state.board[idx].p1) > 0;
}
function canMoveStart(idx, p) {
    return (p===1?state.board[idx].p1:state.board[idx].p2) > 0;
}
function canMoveEnd(from, to) {
    return state.board[from].adj.includes(to);
}
function checkDomination(zone) {
    const diff = zone.p1 - zone.p2;
    if(diff >= 2) zone.dom = 1;
    else if(diff <= -2) zone.dom = -1;
    else zone.dom = 0;
}

/** * --- END GAME CHECKS --- 
 */
function checkGameStatus() {
    if(state.crisis >= 5) {
        state.stability = -10;
        return endGame("ìœ„ê¸° ìˆ˜ì¹˜ ì´ˆê³¼! ì„ ë™ê°€ ìŠ¹ë¦¬.");
    }
    if(state.stability >= 10) return endGame("ì•ˆì •ë„ ìµœëŒ€ì¹˜! ì§‘ì •ê´€ ìŠ¹ë¦¬!");
    if(state.stability <= -10) return endGame("ì•ˆì •ë„ ìµœì €ì¹˜! ì„ ë™ê°€ ìŠ¹ë¦¬!");
}

function endGame(message) {
    state.gameOver = true;
    log(`GAME OVER: ${message}`, 'warn');
    alert(`ê²Œì„ ì¢…ë£Œ!\n\n${message}`);
}

function endRoundPhase() {
    checkGameStatus();
    if(state.gameOver) return;

    // Check if all actions are used (6 actions)
    if (state.actionsLeft === 0) {
        // Both players finished their 6 actions - END ROUND

        // Stability calculation
        let shift = 0;
        state.board.forEach(z => {
            if(z.dom === 1) shift += z.opVal;
            if(z.dom === -1) shift -= z.opVal;
        });
        state.stability += shift;
        log(`ë¼ìš´ë“œ ì¢…ë£Œ. ì•ˆì •ë„ ë³€í™”: ${shift}`, 'sys');
        
        // ğŸš¨ ë‚¨ì€ í•¸ë“œ ì¹´ë“œëŠ” ë‹¤ìŒ ë¼ìš´ë“œë¡œ ì´ì›”ë¨ (ë²„ë ¤ì§€ì§€ ì•ŠìŒ)
        log(`ì§‘ì •ê´€ ì†íŒ¨: ${state.p1Hand.length}ì¥ ìœ ì§€, ì„ ë™ê°€ ì†íŒ¨: ${state.p2Hand.length}ì¥ ìœ ì§€.`, 'sys');
        
        checkGameStatus();
        if(!state.gameOver) {
            state.round++;
            startRound();
        }
        return;
    }

    // Actions remaining, check whose turn it is
    if (state.turnPlayer === 1) {
        // P1's turn is already active if we are here.
        log("ì§‘ì •ê´€ í„´", 'p1');
        updateUI(); // Ensure UI is updated for P1
    } else {
        // AI's turn
        log("ì„ ë™ê°€ í„´", 'p2');
        updateUI();
        setTimeout(aiTurn, 1000);
    }
}

/** * --- AI (GREEDY) --- 
 */
function aiTurn() {
    if(state.gameOver || state.actionsLeft <= 0 || state.turnPlayer !== -1) return;
    
    // 1. Play Card (Only one card per turn)
    // AI Strategy: Use P1 cards as OP first, then Neutral cards as event if needed, then P2 cards.
    let cardIdx = -1;
    
    // Priority 1: Use P1 cards for OP (causes P1 event)
    cardIdx = state.p2Hand.findIndex(card => card.type === 'P1');
    
    // Priority 2: Use Neutral cards for OP
    if (cardIdx === -1) {
        cardIdx = state.p2Hand.findIndex(card => card.type === 'N');
    }
    
    // Priority 3: Use P2 cards for OP
    if (cardIdx === -1) {
        cardIdx = state.p2Hand.findIndex(card => card.type === 'P2');
    }
    
    if (cardIdx === -1) {
        // Should not happen if hand has cards, but just in case
        log("AIê°€ ì¹´ë“œë¥¼ ì‚¬ìš©í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. í„´ ì¢…ë£Œ.", 'p2');
        state.turnPlayer = 1;
        endRoundPhase();
        return;
    }
    
    const card = state.p2Hand[cardIdx];
    
    // Use card
    if(card.type === 'P1') {
        log(`AIê°€ [${card.name}] ì‚¬ìš© -> ì§‘ì •ê´€ ì´ë²¤íŠ¸ ê°•ì œ ë°œë™!`, 'p1');
        triggerEventText(card.text, 1); // P1 benefits
        state.crisis += card.crisis;
    } else {
        log(`AIê°€ [${card.name}] ì‚¬ìš© (OP ${card.op} íšë“)`, 'p2');
    }
    
    state.currentOP += card.op;
    state.p2Hand.splice(cardIdx, 1);
    state.discard.push(card);
    state.actionsLeft--;
    checkGameStatus();
    updateUI();

    // 2. Use OP
    setTimeout(() => {
        while(state.currentOP > 0 && !state.gameOver) {
            let actionDone = false;
            
            // Priority: Deploy to dominate/prevent P1 dom > Remove P1 (2 OP)
            
            // Try Remove P1 (Cost 2)
            if(state.currentOP >= 2) {
                const targets = state.board.filter(z => z.p1 > 0 && z.dom !== -1 && canRemove(z.id, -1));
                if (targets.length > 0) {
                    const z = targets.sort((a,b) => b.p1 - a.p1)[0];
                    z.p1--;
                    state.currentOP -= 2;
                    checkDomination(z);
                    log(`AI: ${z.name}ì—ì„œ ì§‘ì •ê´€ íë¸Œ ì œê±°`, 'p2');
                    actionDone = true;
                }
            }
            
            // Try Crisis Reduction (Cost 2)
            if (!actionDone && state.currentOP >= 2 && state.crisis >= 2) {
                state.currentOP -= 2;
                state.crisis = Math.max(0, state.crisis - 1);
                log("AI: ìœ„ê¸° ìˆ˜ì¹˜ 1 ê°ì†Œ", 'p2');
                actionDone = true;
            }

            // Try Deploy (Cost 1)
            if (!actionDone && state.currentOP >= 1) {
                const deployTargets = state.board.filter(z => canDeploy(z.id, -1));
                if (deployTargets.length > 0) {
                    // Greedy target: most P1, not P2 dominated
                    const z = deployTargets.sort((a,b) => b.p1 - a.p1)[0]; 
                    z.p2++;
                    state.currentOP--;
                    checkDomination(z);
                    log(`AI: ${z.name} ë°°ì¹˜`, 'p2');
                    actionDone = true;
                }
            }
            
            // Fallback: Move (Cost 1) - Very simple move logic
            if (!actionDone && state.currentOP >= 1) {
                for(let i=0; i<state.board.length; i++) {
                    if(state.board[i].p2 > 0) {
                        for(let adj of state.board[i].adj) {
                            if(state.board[adj].dom !== -1) { // Move to non-dominated area
                                state.board[i].p2--;
                                state.board[adj].p2++;
                                state.currentOP--;
                                checkDomination(state.board[i]);
                                checkDomination(state.board[adj]);
                                log(`AI: ${state.board[i].name} -> ${state.board[adj].name} ì´ë™`, 'p2');
                                actionDone = true;
                                break;
                            }
                        }
                    }
                    if(actionDone) break;
                }
            }
            
            if(!actionDone) state.currentOP = 0; 
            updateUI();
        }
        
        // 3. Pass turn back to P1
        state.turnPlayer = 1;
        state.currentOP = 0; // Ensure OP is cleared
        endRoundPhase(); // Logic handles if P1 turn or end round
    }, 1000);
}

function log(msg, type) {
    const el = document.getElementById('log-area');
    const color = type === 'p1' ? 'var(--p1-color)' : type === 'p2' ? 'var(--p2-color)' : type === 'warn' ? '#ff0' : 'var(--neutral-color)';
    el.innerHTML = `<div style="color:${color}">> ${msg}</div>` + el.innerHTML;
    if (el.scrollHeight > el.clientHeight) el.scrollTop = 0; // Scroll to top
}

/** * --- TUTORIAL (Skipped for brevity, same as previous) --- 
 */
const tutorials = [
    { t: "1. ê²Œì„ ëª©í‘œ", c: "ë‹¹ì‹ ì€ <b>ì§‘ì •ê´€(íŒŒë‘)</b>ì…ë‹ˆë‹¤. ë„ì‹œì˜ [ì•ˆì •ë„]ë¥¼ ë†’ì—¬(+10) ì²´ì œë¥¼ ìˆ˜í˜¸í•˜ì„¸ìš”.<br>AIì¸ <b>ì„ ë™ê°€(ë¹¨ê°•)</b>ëŠ” í˜¼ë€ì„ ì¼ìœ¼ì¼œ ì•ˆì •ë„ë¥¼ ë‚®ì¶”ë ¤(-10) í•©ë‹ˆë‹¤. ìŠ¹íŒ¨ëŠ” Â±10 ë˜ëŠ” 6ë¼ìš´ë“œ ì¢…ë£Œ ì‹œ ê²°ì •ë©ë‹ˆë‹¤." },
    { t: "2. ë§µê³¼ ì¥ì•…", c: "ê° êµ¬ì—­ì— íë¸Œë¥¼ ë°°ì¹˜í•´ ì˜í–¥ë ¥ì„ í–‰ì‚¬í•©ë‹ˆë‹¤. ìƒëŒ€ë³´ë‹¤ íë¸Œê°€ 2ê°œ ë” ë§ìœ¼ë©´ <b>[ì¥ì•…]</b> ìƒíƒœê°€ ë˜ì–´ íŠ¹ìˆ˜ ëŠ¥ë ¥ì´ ë°œë™ë˜ê³ , ë¼ìš´ë“œ ëì— ì•ˆì •ë„ ì ìˆ˜(OP Value)ë¥¼ ì–»ìŠµë‹ˆë‹¤." },
    { t: "3. ë”œë ˆë§ˆ (ì¹´ë“œ ì‚¬ìš©)", c: "ì¹´ë“œëŠ” [ì‘ì „(OP)]ê³¼ [ì´ë²¤íŠ¸]ë¡œ ë‚˜ë‰©ë‹ˆë‹¤. ì¤‘ë¦½(ë…¸ë‘) ì¹´ë“œì™€ ë‚´ ì§„ì˜(íŒŒë‘) ì¹´ë“œëŠ” ì´ë²¤íŠ¸ë¡œ ììœ ë¡­ê²Œ ì“¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>ì¤‘ìš”: <b>ìƒëŒ€ë°© ì§„ì˜(ë¹¨ê°•)ì˜ ì¹´ë“œ</b>ë¥¼ ì‘ì „ìš©(OP)ìœ¼ë¡œ ì“°ë©´, <b>ìƒëŒ€ì˜ ì´ë²¤íŠ¸ê°€ ê°•ì œë¡œ ë°œë™</b>ë©ë‹ˆë‹¤!" },
    { t: "4. ìœ„ê¸° ìˆ˜ì¹˜", c: "ê°•ë ¥í•œ ì¹´ë“œ(ğŸ”¥ ì•„ì´ì½˜)ë¥¼ ì´ë²¤íŠ¸ë¡œ ì‚¬ìš©í•˜ê±°ë‚˜ ìƒëŒ€ ì¹´ë“œì— ë”œë ˆë§ˆê°€ ë°œìƒí•˜ë©´ [ìœ„ê¸°]ê°€ ë†’ì•„ì§‘ë‹ˆë‹¤.<br>ìœ„ê¸°ê°€ 5ì— ë„ë‹¬í•˜ë©´ ê·¸ ì¦‰ì‹œ <b>íŒ¨ë°°</b>í•©ë‹ˆë‹¤. [ì¬ì •ë¹„] ì‘ì „(2 OP)ìœ¼ë¡œ ìœ„ê¸°ë¥¼ ë‚®ì¶”ì„¸ìš”." },
    { t: "5. ì‘ì „ ì¢…ë¥˜", c: "<b>ë°°ì¹˜(1)</b>: ì¸ì ‘ êµ¬ì—­ì— íë¸Œ ë†“ê¸°<br><b>ì œê±°(2)</b>: ì  íë¸Œ ì—†ì• ê¸°<br><b>ì´ë™(1)</b>: ë‚´ íë¸Œ ì´ë™<br><b>ì¬ì •ë¹„(2)</b>: ìœ„ê¸° -1" }
];
let tutPage = 0;

function openTutorial() {
    document.getElementById('modal-overlay').style.display = 'flex';
    showTutPage(0);
}
function closeModal() {
    document.getElementById('modal-overlay').style.display = 'none';
}
function showTutPage(idx) {
    tutPage = idx;
    document.getElementById('tut-title').innerText = tutorials[idx].t;
    document.getElementById('tut-content').innerHTML = tutorials[idx].c;
    document.getElementById('tut-page').innerText = `${idx+1} / ${tutorials.length}`;
}
function nextTut() { if(tutPage < tutorials.length -1) showTutPage(tutPage+1); }
function prevTut() { if(tutPage > 0) showTutPage(tutPage-1); }

// Start
init();

</script>
</body>
</html>
