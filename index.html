<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Arena: Factions v1.3</title>
    <style>
        :root {
            --board-size: 720px;
            --tile-size: calc(var(--board-size) / 8);
            --p1-color: #4a90e2; --p1-dark-color: #3b73b5;
            --p2-color: #e24a4a; --p2-dark-color: #b53b3b;
            --gold-color: #f5a623;
            --highlight-move: rgba(74, 144, 226, 0.4);
            --highlight-attack: rgba(226, 74, 74, 0.5);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #2c2f33;
            color: white;
            margin: 0;
            overflow: hidden;
        }

        #game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            position: relative;
            margin-left: 260px; /* Î°úÍ∑∏ Ìå®ÎÑê Í≥µÍ∞Ñ ÌôïÎ≥¥ */
        }

        #game-board {
            width: var(--board-size);
            height: var(--board-size);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border: 5px solid #1a1a1a;
            position: relative;
        }

        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        .tile.light { background-color: #f0d9b5; }
        .tile.dark { background-color: #b58863; }

        /* Tile highlights */
        .tile.selected {
            box-shadow: inset 0 0 0 3px var(--gold-color);
        }
        .tile.valid-move {
            background-color: var(--highlight-move) !important;
        }
        .tile.valid-attack {
            background-color: var(--highlight-attack) !important;
        }
        .tile.spawn {
            background-color: rgba(74, 226, 74, 0.4) !important;
        }

        .tile.forest::before {
            content: 'üå≥';
            position: absolute;
            font-size: calc(var(--tile-size) * 0.8);
            opacity: 0.3;
            z-index: 0;
        }
        .tile.mountain::before {
            content: '‚õ∞Ô∏è';
            position: absolute;
            font-size: calc(var(--tile-size) * 0.6);
            opacity: 0.7;
            z-index: 0;
        }
		.tile .item-gold {
            position: absolute;
            font-size: calc(var(--tile-size) * 0.5);
            z-index: 2;
            animation: bounce-item 1.5s infinite ease-in-out;
        }

        @keyframes bounce-item {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Ïú†Îãõ ÎûòÌçº - Ï†àÎåÄ ÏúÑÏπòÎ°ú Ïï†ÎãàÎ©îÏù¥ÏÖò Í∞ÄÎä• */
        .unit-wrapper {
            position: absolute;
            width: var(--tile-size);
            height: var(--tile-size);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3;
            transition: transform 0.4s ease-in-out;
            pointer-events: none;
        }

        .unit {
            font-size: calc(var(--tile-size) * 0.5);
            line-height: 1;
            user-select: none;
            position: relative;
        }
        /* ÌîºÏïÑ ÏãùÎ≥Ñ Í∞úÏÑ† */
        .unit.player1::after {
            content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 3px; background: var(--p1-color); border-radius: 2px; box-shadow: 0 0 4px var(--p1-color);
        }
        .unit.cpu::after {
            content: ''; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 3px; background: var(--p2-color); border-radius: 2px; box-shadow: 0 0 4px var(--p2-color);
        }

        .unit-hp-bar {
            position: absolute; bottom: 5px; width: 70%; height: 8px; background-color: #555;
            border-radius: 4px; border: 1px solid #000; overflow: hidden;
        }
        .unit-hp-bar-inner { height: 100%; background-color: #4caf50; transition: width 0.3s ease; }

        .base-health {
            position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: white; padding: 2px 6px; border-radius: 3px;
            font-size: 0.8em; font-weight: bold; z-index: 4; min-width: 40px; text-align: center;
        }
        .base-health.player1 { border: 1px solid var(--p1-color); }
        .base-health.cpu { border: 1px solid var(--p2-color); }

        /* Ïï†ÎãàÎ©îÏù¥ÏÖò */
        .unit-wrapper { transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1); }
        .unit-wrapper.attacking { animation: unit-attack 0.6s ease-in-out; z-index: 6; }
        .unit-wrapper.hit { animation: unit-hit 0.4s ease; }
        .unit-wrapper.dying { animation: unit-death 0.8s ease-out forwards; }

        @keyframes unit-attack {
            0% { transform: translate(var(--start-x), var(--start-y)) scale(1); }
            50% { transform: translate(var(--attack-x), var(--attack-y)) scale(1.2); }
            100% { transform: translate(var(--start-x), var(--start-y)) scale(1); }
        }
        @keyframes unit-hit {
            0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); }
        }
        @keyframes unit-death {
             0% { transform: translate(var(--start-x), var(--start-y)) scale(1); opacity: 1; }
            100% { transform: translate(var(--start-x), var(--start-y)) scale(0); opacity: 0; }
        }
        .unit-wrapper.summoning { animation: unit-summon 0.4s ease-out; }
        @keyframes unit-summon {
            0% { transform: translate(var(--start-x), var(--start-y)) scale(0); opacity: 0; }
            80% { transform: translate(var(--start-x), var(--start-y)) scale(1.2); opacity: 1; }
            100% { transform: translate(var(--start-x), var(--start-y)) scale(1); opacity: 1; }
        }

        .damage-popup {
            position: absolute; font-size: 1.5em; font-weight: bold; color: red;
            text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
            z-index: 10; pointer-events: none; animation: float-up 1s ease-out forwards;
        }
        @keyframes float-up {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        /* UI Ìå®ÎÑê */
        #ui-panel {
            width: 280px; padding: 20px; background: #23272a; border-radius: 10px;
            display: flex; flex-direction: column; gap: 15px; max-height: 90vh; overflow-y: auto;
        }
        .player-info { padding: 10px; border-radius: 8px; }
        .player-info.player1 { background: var(--p1-color); }
        .player-info.cpu { background: var(--p2-color); }
        .player-info h3, .player-info p { margin: 0; }
        #turn-info { text-align: center; font-size: 1.2em; font-weight: bold; }
		#difficulty-info { text-align: center; font-size: 0.9em; color: #aaa; margin-top: -10px; }
        .ui-title { margin-bottom: 5px; border-bottom: 1px solid #fff; padding-bottom: 5px; }
        .shop-item {
            display: flex; justify-content: space-between; align-items: center; padding: 8px;
            background: #3a3f44; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; position: relative;
        }
        .shop-item:hover { background: #4a4f54; }
        .shop-item .unit-icon { font-size: 32px; line-height: 1; }

        /* Ìà¥ÌåÅ */
        #unit-tooltip {
            position: fixed; width: 200px; background: rgba(0, 0, 0, 0.95); border: 2px solid var(--gold-color);
            border-radius: 8px; padding: 15px; z-index: 10000; display: none; pointer-events: none;
        }
        #unit-tooltip h4 { margin: 0 0 10px 0; color: var(--gold-color); font-size: 1.1em; }
        #unit-tooltip .stat-row { display: flex; justify-content: space-between; margin: 4px 0; font-size: 0.9em; }
        #unit-tooltip .stat-label { color: #aaa; }
        #unit-tooltip .stat-value { color: #fff; font-weight: bold; }

        #end-turn-btn {
            width: 100%; padding: 15px; font-size: 1.1em; font-weight: bold; cursor: pointer;
            border: none; border-radius: 5px; background-color: #7289da; color: white;
        }
        #end-turn-btn:disabled { background-color: #555; cursor: not-allowed; }

        /* Í≤åÏûÑ Î°úÍ∑∏ */
        #game-log {
            position: fixed; left: 20px; top: 50%; transform: translateY(-50%); width: 220px;
            height: 500px; background: rgba(0, 0, 0, 0.9); border-radius: 10px; padding: 15px;
            color: white; overflow-y: auto; font-size: 0.85em; border: 2px solid #444; z-index: 100;
            display: flex; flex-direction: column;
        }
        #game-log h3 { margin: 0 0 10px 0; padding-bottom: 10px; border-bottom: 1px solid #666; color: #f39c12; }
        #game-log-content { flex: 1; overflow-y: auto; }
        .log-entry {
            margin: 5px 0; padding: 5px; background: rgba(255, 255, 255, 0.1); border-radius: 3px;
            animation: slideIn 0.3s ease; font-size: 0.8em;
        }
        .log-entry.player1 { border-left: 3px solid #7289da; }
        .log-entry.cpu { border-left: 3px solid #e74c3c; }
        .log-entry.system { border-left: 3px solid #f39c12; font-weight: bold; }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

        /* Î™®Îã¨ */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7);
            display: flex; justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background: #2c2f33; padding: 30px; border-radius: 10px; text-align: center; border: 2px solid #7289da;
        }
        .modal-content h2 { margin-top: 0; }
        .modal-content button {
            padding: 10px 20px; font-size: 1em; margin: 5px; cursor: pointer;
            border-radius: 5px; border: none; background-color: #4a4f54; color: white;
        }
        .modal-content button:hover { background-color: #5a5f64; }

        .faction-selection { display: flex; gap: 15px; justify-content: center; margin-top: 20px; }
        .faction-btn {
            display: flex; flex-direction: column; align-items: center; padding: 15px; border: 2px solid transparent;
            cursor: pointer; border-radius: 8px; width: 150px; text-align: center;
            background: rgba(255, 255, 255, 0.05); transition: all 0.3s ease;
        }
        .faction-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
        .faction-btn.selected { border-color: var(--gold-color); background: rgba(245, 166, 35, 0.2); }
        .faction-icon { font-size: 40px; margin-bottom: 8px; }
        .faction-name { font-size: 1.1em; font-weight: bold; margin-bottom: 5px; }
        .faction-desc { font-size: 0.8em; color: #ccc; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-log">
            <h3 data-lang-key="log"></h3>
            <div id="game-log-content"></div>
        </div>

        <div id="game-board"></div>
        <div id="ui-panel">
            <div id="turn-info"></div>
			<div id="difficulty-info"></div>

            <div class="player-info player1">
                <h3 data-lang-key="player1"></h3>
                <p><span data-lang-key="gold"></span>: <span id="p1-gold"></span></p>
            </div>
            <div class="player-info cpu">
                <h3 data-lang-key="cpu"></h3>
                <p><span data-lang-key="gold"></span>: <span id="cpu-gold"></span></p>
            </div>

            <div id="shop" style="position: relative;">
                <h4 class="ui-title" data-lang-key="shop"></h4>
                <div class="shop-item" data-unit="Pawn"><span></span><span class="unit-icon">‚ôü</span></div>
                <div class="shop-item" data-unit="Rook"><span></span><span class="unit-icon">‚ôú</span></div>
                <div class="shop-item" data-unit="Knight"><span></span><span class="unit-icon">‚ôû</span></div>
                <div class="shop-item" data-unit="Bishop"><span></span><span class="unit-icon">‚ôù</span></div>
                <div class="shop-item" data-unit="Queen"><span></span><span class="unit-icon">‚ôõ</span></div>
                <div id="unit-tooltip"></div>
            </div>

            <button id="end-turn-btn" data-lang-key="endTurn"></button>
        </div>
    </div>

    <!-- Î™®Îã¨ -->
    <div class="modal-overlay" id="lang-modal" style="display: none;"><div class="modal-content">
        <h2 data-lang-key="langSelectTitle"></h2>
        <button data-lang="en">English</button> <button data-lang="ja">Êó•Êú¨Ë™û</button> <button data-lang="ko">ÌïúÍµ≠Ïñ¥</button>
    </div></div>
    <div class="modal-overlay" id="tutorial-modal" style="display: none;"><div class="modal-content">
        <h2 data-lang-key="welcome"></h2><p data-lang-key="tutorialPrompt"></p>
        <button id="start-tutorial-btn" data-lang-key="yesTutorial"></button><button id="skip-tutorial-btn" data-lang-key="noTutorial"></button>
    </div></div>
    <div class="modal-overlay" id="faction-modal" style="display: none;"><div class="modal-content">
        <h2 data-lang-key="factionSelect"></h2><p data-lang-key="factionDesc"></p>
        <div class="faction-selection">
            <button class="faction-btn selected" data-faction="human"><div class="faction-icon">üë•</div><div class="faction-name" data-lang-key="human"></div><div class="faction-desc" data-lang-key="humanDesc"></div></button>
            <button class="faction-btn" data-faction="undead"><div class="faction-icon">üíÄ</div><div class="faction-name" data-lang-key="undead"></div><div class="faction-desc" data-lang-key="undeadDesc"></div></button>
            <button class="faction-btn" data-faction="elf"><div class="faction-icon">üßù</div><div class="faction-name" data-lang-key="elf"></div><div class="faction-desc" data-lang-key="elfDesc"></div></button>
        </div>
        <button id="confirm-faction-btn" style="margin-top: 20px;" data-lang-key="confirmFaction"></button>
    </div></div>
    <div class="modal-overlay" id="difficulty-modal" style="display: none;"><div class="modal-content">
        <h2 data-lang-key="difficultySelect"></h2><p data-lang-key="difficultyDesc"></p>
        <button class="difficulty-btn" data-difficulty="easy" data-lang-key="easy"></button>
        <button class="difficulty-btn" data-difficulty="medium" data-lang-key="medium"></button>
        <button class="difficulty-btn" data-difficulty="hard" data-lang-key="hard"></button>
    </div></div>
    <div class="modal-overlay" id="game-over-modal" style="display: none;"><div class="modal-content">
        <h2 id="game-over-title"></h2><p id="game-over-message"></p><button id="restart-btn" data-lang-key="restart"></button>
    </div></div>

    <script>
    let currentLang = 'ko';
    let LANG_STRINGS = {};

    document.addEventListener('DOMContentLoaded', () => {
        LANG_STRINGS = {
            en: {
                langSelectTitle: "Select Language", welcome: "Welcome to Chess Arena!", tutorialPrompt: "Would you like to play the tutorial to learn the basics?",
                yesTutorial: "Yes (Recommended)", noTutorial: "No, skip it", factionSelect: "Select Faction", factionDesc: "Choose your faction. Each has a unique perk.",
                human: "Human", humanDesc: "A well-balanced faction.", undead: "Undead", undeadDesc: "Summons a skeleton when a unit dies.", elf: "Elf", elfDesc: "Gains bonus attack in forest terrain.",
                confirmFaction: "Start with this Faction", difficultySelect: "Select Difficulty", difficultyDesc: "Choose the CPU's difficulty level.",
                easy: "Easy", medium: "Medium", hard: "Hard", restart: "Back to Start", gold: "Gold", attack: "Attack", hp: "HP", cost: "Cost",
                moveRange: "Move Range", attackRange: "Attack Range", shop: "Unit Shop", log: "Game Log", endTurn: "End Turn",
                turnInfo: "Turn {turn} - {player}'s Turn", difficultyLabel: "Difficulty", pawn: "Pawn", rook: "Rook", knight: "Knight", bishop: "Bishop", queen: "Queen",
                player1: "Player 1", cpu: "CPU", msgGold: "Not enough gold.", msgSpawn: "Can only place on empty tiles near your base.", msgPlaced: "{unit} placed successfully!",
                wins: "{winner} Wins!", next: "Next", log_buy: "{player} bought {unit}", log_move: "{player}'s {unit} moved to ({x}, {y})", log_gold_item: "{player} acquired a gold pouch! (+{gold} Gold)",
                log_attack: "{attackerUnit} attacked {targetUnit} for {damage} damage", log_destroy: "{unit} was destroyed", log_base_destroy: "The {owner}'s base was destroyed!",
                log_item_spawn: "A gold pouch appeared on the board!", log_turn_start: "===== {player}'s turn starts =====", log_turn_end: "{player}'s turn ends",
            },
            ja: {
                langSelectTitle: "Ë®ÄË™û„ÇíÈÅ∏Êäû", welcome: "„ÉÅ„Çß„Çπ„Éª„Ç¢„É™„Éº„Éä„Å∏„Çà„ÅÜ„Åì„ÅùÔºÅ", tutorialPrompt: "Âü∫Êú¨„ÇíÂ≠¶„Å∂„Åü„ÇÅ„Å´„ÉÅ„É•„Éº„Éà„É™„Ç¢„É´„Çí„Éó„É¨„Ç§„Åó„Åæ„Åô„ÅãÔºü",
                yesTutorial: "„ÅØ„ÅÑÔºàÊé®Â•®Ôºâ", noTutorial: "„ÅÑ„ÅÑ„Åà", factionSelect: "Âã¢Âäõ„ÅÆÈÅ∏Êäû", factionDesc: "„ÅÇ„Å™„Åü„ÅÆÂã¢Âäõ„ÇíÈÅ∏„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ„Åù„Çå„Åû„Çå„Å´„É¶„Éã„Éº„ÇØ„Å™ÁâπÂÖ∏„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ",
                human: "„Éí„É•„Éº„Éû„É≥", humanDesc: "„Éê„É©„É≥„Çπ„ÅÆÂèñ„Çå„ÅüÂã¢Âäõ„Åß„Åô„ÄÇ", undead: "„Ç¢„É≥„Éá„ÉÉ„Éâ", undeadDesc: "„É¶„Éã„ÉÉ„Éà„ÅåÂÄí„Åï„Çå„Çã„Å®„Çπ„Ç±„É´„Éà„É≥„ÇíÂè¨Âñö„Åó„Åæ„Åô„ÄÇ", elf: "„Ç®„É´„Éï", elfDesc: "Ê£Æ„ÅÆÂú∞ÂΩ¢„ÅßÊîªÊíÉ„Éú„Éº„Éä„Çπ„ÇíÂæó„Åæ„Åô„ÄÇ",
                confirmFaction: "„Åì„ÅÆÂã¢Âäõ„ÅßÈñãÂßã", difficultySelect: "Èõ£ÊòìÂ∫¶„ÅÆÈÅ∏Êäû", difficultyDesc: "CPU„ÅÆÈõ£ÊòìÂ∫¶„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                easy: "„Ç§„Éº„Ç∏„Éº", medium: "„Éü„Éá„Ç£„Ç¢„É†", hard: "„Éè„Éº„Éâ", restart: "ÊúÄÂàù„Åã„Çâ", gold: "„Ç¥„Éº„É´„Éâ", attack: "ÊîªÊíÉÂäõ", hp: "HP", cost: "„Ç≥„Çπ„Éà",
                moveRange: "ÁßªÂãïÁØÑÂõ≤", attackRange: "ÊîªÊíÉÁØÑÂõ≤", shop: "„É¶„Éã„ÉÉ„Éà„Ç∑„Éß„ÉÉ„Éó", log: "„Ç≤„Éº„É†„É≠„Ç∞", endTurn: "„Çø„Éº„É≥ÁµÇ‰∫Ü",
                turnInfo: "{turn}„Çø„Éº„É≥ÁõÆ - {player}„ÅÆÁï™", difficultyLabel: "Èõ£ÊòìÂ∫¶", pawn: "„Éù„Éº„É≥", rook: "„É´„Éº„ÇØ", knight: "„Éä„Ç§„Éà", bishop: "„Éì„Ç∑„Éß„ÉÉ„Éó", queen: "„ÇØ„Ç§„Éº„É≥",
                player1: "„Éó„É¨„Ç§„É§„Éº1", cpu: "CPU", msgGold: "„Ç¥„Éº„É´„Éâ„ÅåË∂≥„Çä„Åæ„Åõ„Çì„ÄÇ", msgSpawn: "Êú¨Êã†Âú∞„ÅÆÂë®„Çä„ÅÆÁ©∫„Åç„Çø„Ç§„É´„Å´„ÅÆ„ÅøÈÖçÁΩÆ„Åß„Åç„Åæ„Åô„ÄÇ", msgPlaced: "{unit} ÈÖçÁΩÆÂÆå‰∫ÜÔºÅ",
                wins: "{winner}„ÅÆÂãùÂà©ÔºÅ", next: "Ê¨°„Å∏", log_buy: "{player}„Åå{unit}„ÇíË≥ºÂÖ•„Åó„Åæ„Åó„Åü", log_move: "{player}„ÅÆ{unit}„Åå({x}, {y})„Å´ÁßªÂãï„Åó„Åæ„Åó„Åü", log_gold_item: "{player}„Åå„Ç¥„Éº„É´„ÉâË¢ã„ÇíÁç≤Âæó„Åó„Åæ„Åó„ÅüÔºÅ (+{gold} „Ç¥„Éº„É´„Éâ)",
                log_attack: "{attackerUnit}„Åå{targetUnit}„Å´{damage}„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åó„Åü", log_destroy: "{unit}„ÅåÁ†¥Â£ä„Åï„Çå„Åæ„Åó„Åü", log_base_destroy: "{owner}„ÅÆÊú¨Êã†Âú∞„ÅåÁ†¥Â£ä„Åï„Çå„Åæ„Åó„ÅüÔºÅ",
                log_item_spawn: "„Éú„Éº„Éâ„Å´„Ç¥„Éº„É´„ÉâË¢ã„ÅåÁèæ„Çå„Åæ„Åó„ÅüÔºÅ", log_turn_start: "===== {player}„ÅÆ„Çø„Éº„É≥ÈñãÂßã =====", log_turn_end: "{player}„ÅÆ„Çø„Éº„É≥ÁµÇ‰∫Ü",
            },
            ko: {
                langSelectTitle: "Ïñ∏Ïñ¥ ÏÑ†ÌÉù", welcome: "Ï≤¥Ïä§ ÏïÑÎ†àÎÇòÏóê Ïò§Ïã† Í≤ÉÏùÑ ÌôòÏòÅÌï©ÎãàÎã§!", tutorialPrompt: "Í≤åÏûÑÏùò Í∏∞Î≥∏ÏùÑ Î∞∞Ïö∞Í∏∞ ÏúÑÌï¥ ÌäúÌÜ†Î¶¨ÏñºÏùÑ ÏßÑÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
                yesTutorial: "Ïòà (Ï∂îÏ≤ú)", noTutorial: "ÏïÑÎãàÏò§", factionSelect: "Ï¢ÖÏ°± ÏÑ†ÌÉù", factionDesc: "ÌîåÎ†àÏù¥Ìï† Ï¢ÖÏ°±ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî. Í∞Å Ï¢ÖÏ°±ÏùÄ Í≥†Ïú†Ìïú ÌäπÏÑ±ÏùÑ Í∞ÄÏßëÎãàÎã§.",
                human: "Ìú¥Î®º", humanDesc: "Í∞ÄÏû• Í∑†ÌòïÏû°Ìûå Ï¢ÖÏ°±ÏûÖÎãàÎã§.", undead: "Ïñ∏Îç∞Îìú", undeadDesc: "ÏûêÏã†Ïùò Ïú†ÎãõÏù¥ Ï£ΩÏúºÎ©¥ Í∑∏ ÏûêÎ¶¨Ïóê Ìï¥Í≥®ÏùÑ ÏÜåÌôòÌï©ÎãàÎã§.", elf: "ÏóòÌîÑ", elfDesc: "Ïà≤ ÏßÄÌòïÏóêÏÑú Ï∂îÍ∞Ä Í≥µÍ≤©Î†•ÏùÑ ÏñªÏäµÎãàÎã§.",
                confirmFaction: "Ïù¥ Ï¢ÖÏ°±ÏúºÎ°ú ÏãúÏûë", difficultySelect: "ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù", difficultyDesc: "CPUÏùò ÎÇúÏù¥ÎèÑÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.",
                easy: "Ïâ¨ÏõÄ", medium: "Î≥¥ÌÜµ", hard: "Ïñ¥Î†§ÏõÄ", restart: "Ï≤òÏùåÏúºÎ°ú", gold: "Í≥®Îìú", attack: "Í≥µÍ≤©Î†•", hp: "Ï≤¥Î†•", cost: "ÎπÑÏö©",
                moveRange: "Ïù¥Îèô Î≤îÏúÑ", attackRange: "Í≥µÍ≤© Î≤îÏúÑ", shop: "Ïú†Îãõ ÏÉÅÏ†ê", log: "Í≤åÏûÑ Î°úÍ∑∏", endTurn: "ÌÑ¥ Ï¢ÖÎ£å",
                turnInfo: "{turn}ÌÑ¥ - {player} Îãò Ï∞®Î°Ä", difficultyLabel: "ÎÇúÏù¥ÎèÑ", pawn: "Î≥¥Î≥ë", rook: "ÌÉÄÏõå", knight: "Í∏∞ÏÇ¨", bishop: "ÎßàÎ≤ïÏÇ¨", queen: "Ïó¨Ïôï",
                player1: "ÌîåÎ†àÏù¥Ïñ¥ 1", cpu: "CPU", msgGold: "Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.", msgSpawn: "Í∏∞ÏßÄ Ï£ºÎ≥ÄÏùò Îπà ÌÉÄÏùºÏóêÎßå Î∞∞ÏπòÌï† Ïàò ÏûàÏäµÎãàÎã§.", msgPlaced: "{unit} Î∞∞Ïπò ÏôÑÎ£å!",
                wins: "{winner}Ïùò ÏäπÎ¶¨!", next: "Îã§Ïùå", log_buy: "{player}Í∞Ä {unit}ÏùÑ(Î•º) Íµ¨Îß§ÌñàÏäµÎãàÎã§", log_move: "{player}Ïùò {unit}Ïù¥(Í∞Ä) ({x}, {y})Î°ú Ïù¥ÎèôÌñàÏäµÎãàÎã§", log_gold_item: "{player}Í∞Ä Í≥®Îìú Ï£ºÎ®∏ÎãàÎ•º ÌöçÎìùÌñàÏäµÎãàÎã§! (+{gold} Í≥®Îìú)",
                log_attack: "{attackerUnit}Ïù¥(Í∞Ä) {targetUnit}ÏùÑ(Î•º) Í≥µÍ≤©Ìï¥ {damage}Ïùò ÌîºÌï¥Î•º ÏûÖÌòîÏäµÎãàÎã§", log_destroy: "{unit}Ïù¥(Í∞Ä) ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§", log_base_destroy: "{owner}Ïùò Í∏∞ÏßÄÍ∞Ä ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§!",
                log_item_spawn: "Î≥¥ÎìúÏóê Í≥®Îìú Ï£ºÎ®∏ÎãàÍ∞Ä ÎÇòÌÉÄÎÇ¨ÏäµÎãàÎã§!", log_turn_start: "===== {player}Ïùò ÌÑ¥ ÏãúÏûë =====", log_turn_end: "{player}Ïùò ÌÑ¥Ïù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§",
            }
        };

        window.t = (key, params = {}) => {
            let lang = LANG_STRINGS[currentLang] || LANG_STRINGS['en'];
            if (!lang[key]) lang = LANG_STRINGS['en'];
            let str = lang[key] || key;
            for (const p in params) str = str.replace(new RegExp(`\{${p}\}`, 'g'), params[p]);
            return str;
        };

        function updateAllUIText() {
            document.querySelectorAll('[data-lang-key]').forEach(el => {
                el.textContent = t(el.dataset.langKey);
            });
            document.querySelectorAll('.shop-item').forEach(item => {
                const unit = item.dataset.unit;
                if (unit && UNIT_STATS[unit]) {
                    item.querySelector('span').textContent = `${t(unit.toLowerCase())} (${UNIT_STATS[unit].cost}G)`;
                }
            });
			updateUIElements();
        }

		const GAME_CONFIG = {
			BOARD_SIZE: 8, INITIAL_GOLD: 50, BASE_HP: 100, GOLD_PER_TURN: 10,
			ITEM_SPAWN_RATE: 4, ITEM_GOLD_AMOUNT: 20
		};
        const UNIT_STATS = {
            'Base': { hp: GAME_CONFIG.BASE_HP, attack: 0, cost: 0, moveRange: 0, attackRange: 0 },
            'Pawn': { hp: 30, attack: 12, cost: 10, moveRange: 1, attackRange: 1 },
            'Rook': { hp: 50, attack: 20, cost: 25, moveRange: 3, attackRange: 1 },
            'Knight': { hp: 35, attack: 15, cost: 20, moveRange: 2, attackRange: 1 },
            'Bishop': { hp: 20, attack: 25, cost: 30, moveRange: 2, attackRange: 4 },
            'Queen': { hp: 45, attack: 30, cost: 60, moveRange: 2, attackRange: 2 },
            'Skeleton': { hp: 10, attack: 5, cost: 0, moveRange: 1, attackRange: 1 }
        };

        let gameState = {};

        function resetGameState() {
            gameState = {
                board: Array(GAME_CONFIG.BOARD_SIZE).fill(null).map(() => Array(GAME_CONFIG.BOARD_SIZE).fill(null).map(() => ({ unit: null, terrain: null, item: null }))),
                currentPlayer: 'player1', turn: 1,
                players: { 'player1': { gold: GAME_CONFIG.INITIAL_GOLD, faction: 'human' }, 'cpu': { gold: GAME_CONFIG.INITIAL_GOLD, faction: 'human' } },
                gameOver: false, selectedUnit: null, unitToBuy: null, cpuDifficulty: 'medium', isTutorial: false
            };
        }

        const boardEl = document.getElementById('game-board');
        const turnInfoEl = document.getElementById('turn-info');
		const difficultyInfoEl = document.getElementById('difficulty-info');

        function initBoard() {
            boardEl.innerHTML = '';
            for (let y = 0; y < GAME_CONFIG.BOARD_SIZE; y++) {
                for (let x = 0; x < GAME_CONFIG.BOARD_SIZE; x++) {
                    const tile = document.createElement('div');
                    tile.className = `tile ${(x + y) % 2 === 0 ? 'light' : 'dark'}`;
                    tile.dataset.x = x; tile.dataset.y = y;
                    boardEl.appendChild(tile);
                }
            }
        }

        function startGame() {
            const selectedDifficulty = gameState.cpuDifficulty;
            const tutorialEnabled = gameState.isTutorial;
            resetGameState();
            gameState.cpuDifficulty = selectedDifficulty;
            gameState.isTutorial = tutorialEnabled;
            gameState.players.player1.faction = selectedPlayerFaction;
            gameState.players.cpu.faction = selectedCpuFaction;
            initializeBoard();
            renderGame();
            updateAllUIText();
            Logger.clear();
            Logger.add(t('log_turn_start', { player: t('player1') }), 'system');
            if (gameState.isTutorial) {
                Logger.add("ÌäúÌÜ†Î¶¨Ïñº: ÏÉÅÏ†êÏóêÏÑú Ïú†ÎãõÏùÑ Íµ¨Îß§(ÌÅ¥Î¶≠)ÌïòÍ≥†, Í∏∞ÏßÄ Í∑ºÏ≤ò Îπà ÌÉÄÏùº(ÎÖπÏÉâ)Ïóê Î∞∞ÏπòÌïòÏÑ∏Ïöî. ÏûêÏã†Ïùò Ïú†ÎãõÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Ïù¥Îèô(ÌååÎûÄÏÉâ)ÌïòÍ±∞ÎÇò Í≥µÍ≤©(Îπ®Í∞ÑÏÉâ)Ìï† Ïàò ÏûàÏäµÎãàÎã§. Ï†ÅÏùò Í∏∞ÏßÄÎ•º Î™®Îëê ÌååÍ¥¥ÌïòÎ©¥ ÏäπÎ¶¨Ìï©ÎãàÎã§!", 'system');
            }
        }

        function initializeBoard() {
            gameState.board[7][3].unit = { type: 'Base', owner: 'player1', hp: GAME_CONFIG.BASE_HP };
            gameState.board[7][4].unit = { type: 'Base', owner: 'player1', hp: GAME_CONFIG.BASE_HP };
            gameState.board[0][3].unit = { type: 'Base', owner: 'cpu', hp: GAME_CONFIG.BASE_HP };
            gameState.board[0][4].unit = { type: 'Base', owner: 'cpu', hp: GAME_CONFIG.BASE_HP };
        }

        function renderGame() {
            boardEl.querySelectorAll('.unit-wrapper, .item-gold').forEach(el => el.remove());
            boardEl.querySelectorAll('.tile').forEach(tile => tile.classList.remove('forest', 'mountain'));

            for (let y = 0; y < GAME_CONFIG.BOARD_SIZE; y++) {
                for (let x = 0; x < GAME_CONFIG.BOARD_SIZE; x++) {
                    const cell = gameState.board[y][x];
                    const tile = boardEl.querySelector(`.tile[data-x="${x}"][data-y="${y}"]`);
                    if (!tile) continue;
                    if (cell.terrain) tile.classList.add(cell.terrain);
                    if (cell.item?.type === 'gold') tile.innerHTML += '<div class="item-gold">üí∞</div>';

                    if (cell.unit) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'unit-wrapper';
                        wrapper.style.transform = `translate(${x * 90}px, ${y * 90}px)`;
                        wrapper.dataset.x = x; wrapper.dataset.y = y;
                        const unitEl = document.createElement('div');
                        unitEl.className = `unit ${cell.unit.owner}`;
                        unitEl.textContent = getUnitIcon(cell.unit.type);
                        wrapper.appendChild(unitEl);
                        const maxHp = UNIT_STATS[cell.unit.type].hp;
                        if (cell.unit.type !== 'Base') {
                            wrapper.innerHTML += `<div class="unit-hp-bar"><div class="unit-hp-bar-inner" style="width:${(cell.unit.hp / maxHp) * 100}%"></div></div>`;
                        } else {
                            wrapper.innerHTML += `<div class="base-health ${cell.unit.owner}">${cell.unit.hp}/${maxHp}</div>`;
                        }
                        boardEl.appendChild(wrapper);
                    }
                }
            }
        }

        function getUnitIcon(type) {
            return {'Pawn': '‚ôü','Rook': '‚ôú','Knight': '‚ôû','Bishop': '‚ôó','Queen': '‚ôõ','Skeleton': 'üíÄ','Base': 'üè∞'}[type] || '?';
        }

        function updateUIElements() {
            if (!gameState.players) return;
            turnInfoEl.textContent = t('turnInfo', { turn: gameState.turn, player: t(gameState.currentPlayer) });
			difficultyInfoEl.textContent = `${t('difficultyLabel')}: ${t(gameState.cpuDifficulty)}`;
            document.getElementById('p1-gold').textContent = gameState.players.player1.gold;
            document.getElementById('cpu-gold').textContent = gameState.players.cpu.gold;
        }

        async function placeUnit(type, x, y, owner) {
            const cost = UNIT_STATS[type].cost;
            gameState.players[owner].gold -= cost;
            gameState.board[y][x].unit = {
                type, owner, hp: UNIT_STATS[type].hp, attack: UNIT_STATS[type].attack,
                hasMoved: false, hasAttacked: false, summonedThisTurn: true
            };
            Logger.add(t('log_buy', { player: t(owner), unit: t(type.toLowerCase()) }), owner);
            updateUIElements(); renderGame();
            await new Promise(resolve => setTimeout(resolve, 50));
            const unitElement = boardEl.querySelector(`.unit-wrapper[data-x="${x}"][data-y="${y}"]`);
            if (unitElement) {
                unitElement.style.setProperty('--start-x', `${x * 90}px`);
                unitElement.style.setProperty('--start-y', `${y * 90}px`);
                unitElement.classList.add('summoning');
                await new Promise(resolve => setTimeout(resolve, 400));
                unitElement.classList.remove('summoning');
            }
        }

        async function moveUnit(selected, x, y) {
            const unitElement = boardEl.querySelector(`.unit-wrapper[data-x="${selected.x}"][data-y="${selected.y}"]`);
            if (unitElement) {
                unitElement.style.transform = `translate(${x * 90}px, ${y * 90}px)`;
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            const movedUnit = selected.unit;
            gameState.board[y][x].unit = movedUnit;
            gameState.board[selected.y][selected.x].unit = null;
            movedUnit.hasMoved = true; movedUnit.hasAttacked = true; // Ïù¥Îèô Ïãú Í≥µÍ≤© Î∂àÍ∞Ä
            Logger.add(t('log_move', { player: t(movedUnit.owner), unit: t(movedUnit.type.toLowerCase()), x, y }), movedUnit.owner);
            const cell = gameState.board[y][x];
            if (cell.item?.type === 'gold') {
                gameState.players[movedUnit.owner].gold += cell.item.amount;
                Logger.add(t('log_gold_item', { player: t(movedUnit.owner), gold: cell.item.amount }), movedUnit.owner);
                cell.item = null;
                updateUIElements();
            }
            renderGame();
        }

        async function attackUnit(attacker, target, x, y) {
            const attackerElement = boardEl.querySelector(`.unit-wrapper[data-x="${attacker.x}"][data-y="${attacker.y}"]`);
            if (attackerElement) {
                attackerElement.style.setProperty('--start-x', `${attacker.x * 90}px`);
                attackerElement.style.setProperty('--start-y', `${attacker.y * 90}px`);
                attackerElement.style.setProperty('--attack-x', `${((x - attacker.x) * 30) + (attacker.x * 90)}px`);
                attackerElement.style.setProperty('--attack-y', `${((y - attacker.y) * 30) + (attacker.y * 90)}px`);
                attackerElement.classList.add('attacking');
                await new Promise(resolve => setTimeout(resolve, 600));
                attackerElement.classList.remove('attacking');
            }
            const damage = attacker.unit.attack;
            const damagePopup = document.createElement('div');
            damagePopup.className = 'damage-popup'; damagePopup.textContent = `-${damage}`;
            damagePopup.style.left = `${x * 90 + 30}px`; damagePopup.style.top = `${y * 90 + 20}px`;
            boardEl.appendChild(damagePopup);
            setTimeout(() => damagePopup.remove(), 1000);
            target.hp -= damage;
            Logger.add(t('log_attack', { attackerUnit: t(attacker.unit.type.toLowerCase()), targetUnit: t(target.type.toLowerCase()), damage }), attacker.unit.owner);
            attacker.unit.hasAttacked = true; attacker.unit.hasMoved = true; // Í≥µÍ≤© Ïãú Ïù¥Îèô Î∂àÍ∞Ä
            if (target.hp <= 0) {
                const targetElement = boardEl.querySelector(`.unit-wrapper[data-x="${x}"][data-y="${y}"]`);
                if(targetElement) {
                    targetElement.style.setProperty('--start-x', `${x * 90}px`);
                    targetElement.style.setProperty('--start-y', `${y * 90}px`);
                    targetElement.classList.add('dying');
                    await new Promise(resolve => setTimeout(resolve, 800));
                }
                handleUnitDeath(target, x, y);
            }
            renderGame();
        }

        function handleUnitDeath(unit, x, y) {
            Logger.add(t('log_destroy', { unit: t(unit.type.toLowerCase()) }), 'system');
            const owner = unit.owner;
            gameState.board[y][x].unit = null;
            if (gameState.players[owner].faction === 'undead' && unit.type !== 'Base' && unit.type !== 'Skeleton') {
                gameState.board[y][x].unit = { type: 'Skeleton', owner, hp: 10, attack: 5, hasMoved: false, hasAttacked: false, summonedThisTurn: false };
            }
            if (unit.type === 'Base') {
                let hasOtherBases = false;
                for (let row of gameState.board) for (let cell of row) if (cell.unit?.type === 'Base' && cell.unit.owner === owner) hasOtherBases = true;
                if (!hasOtherBases) endGame(owner === 'player1' ? 'cpu' : 'player1');
            }
        }

        function getValidMoves(type, x, y, owner) {
            const moves = [];
            const patterns = {'Pawn': owner === 'player1' ? [[0, -1]] : [[0, 1]], 'Rook': [[0, 1], [0, -1], [1, 0], [-1, 0]], 'Knight': [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]], 'Bishop': [[1, 1], [1, -1], [-1, 1], [-1, -1]], 'Queen': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]], 'Skeleton': [[0, 1], [0, -1], [1, 0], [-1, 0]]}[type] || [];
            const moveRange = UNIT_STATS[type].moveRange;
            for (const [dx, dy] of patterns) {
                for (let i = 1; i <= moveRange; i++) {
                    const newX = x + dx * i, newY = y + dy * i;
                    if (newX < 0 || newX >= 8 || newY < 0 || newY >= 8) break;
                    const cell = gameState.board[newY][newX];
                    if (!cell.unit && cell.terrain !== 'mountain') moves.push({ x: newX, y: newY }); else break;
                    if (type === 'Pawn' || type === 'Knight') break;
                }
            } return moves;
        }

        function getValidAttacks(type, x, y, owner) {
            const attacks = [];
            const movePatterns = {'Pawn': owner === 'player1' ? [[0, -1]] : [[0, 1]], 'Rook': [[0, 1], [0, -1], [1, 0], [-1, 0]], 'Knight': [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]], 'Bishop': [[1, 1], [1, -1], [-1, 1], [-1, -1]], 'Queen': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]], 'Skeleton': [[0, 1], [0, -1], [1, 0], [-1, 0]]}[type] || [];
            const patterns = (type === 'Pawn' ? (owner === 'player1' ? [[1, -1], [-1, -1]] : [[1, 1], [-1, 1]]) : movePatterns);
            const attackRange = UNIT_STATS[type].attackRange;
            for (const [dx, dy] of patterns) {
                for (let i = 1; i <= attackRange; i++) {
                    const newX = x + dx * i, newY = y + dy * i;
                    if (newX < 0 || newX >= 8 || newY < 0 || newY >= 8) break;
                    const target = gameState.board[newY][newX].unit;
                    if (target) { if (target.owner !== owner) attacks.push({ x: newX, y: newY }); break; }
                    if (type === 'Pawn' || type === 'Knight') break;
                }
            } return attacks;
        }

        function showValidActions(unit, x, y) {
            clearHighlights();
            boardEl.querySelector(`.tile[data-x="${x}"][data-y="${y}"]`)?.classList.add('selected');
            if (!unit.hasMoved && !unit.summonedThisTurn) getValidMoves(unit.type, x, y, unit.owner).forEach(m => boardEl.querySelector(`.tile[data-x="${m.x}"][data-y="${m.y}"]`)?.classList.add('valid-move'));
            if (!unit.hasAttacked) getValidAttacks(unit.type, x, y, unit.owner).forEach(a => boardEl.querySelector(`.tile[data-x="${a.x}"][data-y="${a.y}"]`)?.classList.add('valid-attack'));
        }
        function clearHighlights() { boardEl.querySelectorAll('.tile.selected, .tile.valid-move, .tile.valid-attack, .tile.spawn').forEach(t => t.classList.remove('selected', 'valid-move', 'valid-attack', 'spawn')); }

        function endGame(winner) {
            if (gameState.gameOver) return; gameState.gameOver = true;
            document.getElementById('game-over-title').textContent = t('wins', { winner: t(winner) });
            document.getElementById('game-over-modal').style.display = 'flex';
        }

        const Logger = {
            entries: [], maxMessages: 50,
            add(message, ownerClass = 'system') { this.entries.unshift({ message, ownerClass }); if(this.entries.length > this.maxMessages) this.entries.pop(); this.render(); },
            render() { document.getElementById('game-log-content').innerHTML = this.entries.map(e => `<div class="log-entry ${e.ownerClass}">${e.message}</div>`).join(''); },
            clear() { this.entries = []; this.render(); }
        };
		
		const AI = {
			async takeTurn() {
				if (gameState.gameOver) return;
				Logger.add("ü§ñ CPUÍ∞Ä Ï†ÑÎûµÏùÑ Íµ¨ÏÉÅ Ï§ëÏûÖÎãàÎã§...", 'cpu');
				await new Promise(resolve => setTimeout(resolve, 500));
				
				const ownUnits = [];
				for(let y = 0; y < 8; y++) for(let x = 0; x < 8; x++) if(gameState.board[y][x].unit?.owner === 'cpu' && gameState.board[y][x].unit.type !== 'Base') ownUnits.push({unit: gameState.board[y][x].unit, x, y});

				// 1. Attack phase
				for (const u of ownUnits) {
					if (u.unit.hasAttacked) continue;
					const attacks = getValidAttacks(u.unit.type, u.x, u.y, 'cpu').map(a => ({...a, target: gameState.board[a.y][a.x].unit})).sort((a,b) => UNIT_STATS[b.target.type].cost - UNIT_STATS[a.target.type].cost);
					if (attacks.length > 0) {
						Logger.add(`‚öîÔ∏è CPU: ${t(u.unit.type.toLowerCase())}(Ïúº)Î°ú ${t(attacks[0].target.type.toLowerCase())} Í≥µÍ≤©!`, 'cpu');
						await attackUnit(u, attacks[0].target, attacks[0].x, attacks[0].y);
						await new Promise(resolve => setTimeout(resolve, 800));
						if (gameState.gameOver) return;
					}
				}
				
				// 2. Move phase
				for (const u of ownUnits) {
					if (u.unit.hasMoved || u.unit.summonedThisTurn) continue;
					const moves = getValidMoves(u.unit.type, u.x, u.y, 'cpu');
					if (moves.length > 0) {
						const bestMove = moves.sort((a, b) => b.y - a.y)[0]; // Simplistic: move forward
						await moveUnit(u, bestMove.x, bestMove.y);
						await new Promise(resolve => setTimeout(resolve, 500));
					}
				}

				// 3. Buy phase
				const gold = gameState.players.cpu.gold;
				let purchasePriority = [];
				if (gameState.turn <= 4) purchasePriority = ['Pawn', 'Knight'];
				else purchasePriority = ['Queen', 'Rook', 'Bishop', 'Knight', 'Pawn'];

				const unitToBuy = purchasePriority.find(type => UNIT_STATS[type].cost <= gold);
				if (unitToBuy) {
					const spawnPositions = [];
					for (let y = 0; y < 3; y++) for (let x = 0; x < 8; x++) if (!gameState.board[y][x].unit) spawnPositions.push({x,y});
					if(spawnPositions.length > 0) {
						Logger.add(`ü§ñ CPU: Ï†ÑÎûµÏ†Å Ïú†Îãõ Íµ¨Îß§ - ${t(unitToBuy.toLowerCase())}`, 'cpu');
						const pos = spawnPositions[Math.floor(Math.random() * spawnPositions.length)];
						await placeUnit(unitToBuy, pos.x, pos.y, 'cpu');
						await new Promise(resolve => setTimeout(resolve, 800));
					}
				}
				endTurn();
			}
		};

        boardEl.addEventListener('click', async (e) => {
            const tile = e.target.closest('.tile');
            if (!tile || gameState.gameOver || gameState.currentPlayer !== 'player1') return;
            const x = parseInt(tile.dataset.x), y = parseInt(tile.dataset.y);
            if (gameState.unitToBuy) {
                if ((y >= 6 && !gameState.board[y][x].unit)) {
                    await placeUnit(gameState.unitToBuy, x, y, 'player1');
                    gameState.unitToBuy = null; clearHighlights();
                } return;
            }
            const unit = gameState.board[y][x].unit;
            if (gameState.selectedUnit) {
                const sel = gameState.selectedUnit;
                if (!sel.unit.hasMoved && !sel.unit.summonedThisTurn && getValidMoves(sel.unit.type, sel.x, sel.y, 'player1').some(m => m.x === x && m.y === y)) {
                    await moveUnit(sel, x, y);
                } else if (!sel.unit.hasAttacked && unit?.owner === 'cpu' && getValidAttacks(sel.unit.type, sel.x, sel.y, 'player1').some(a => a.x === x && a.y === y)) {
                    await attackUnit(sel, unit, x, y);
                }
                gameState.selectedUnit = null; clearHighlights();
            } else if (unit?.owner === 'player1' && unit.type !== 'Base') {
                gameState.selectedUnit = { unit, x, y }; showValidActions(unit, x, y);
            }
        });

        document.getElementById('end-turn-btn').addEventListener('click', () => { if (gameState.currentPlayer === 'player1' && !gameState.gameOver) endTurn(); });

        function endTurn() {
            Logger.add(t('log_turn_end', { player: t(gameState.currentPlayer) }), 'system');
            for (let r of gameState.board) for (let c of r) if (c.unit?.owner === gameState.currentPlayer) { c.unit.hasMoved = false; c.unit.hasAttacked = false; c.unit.summonedThisTurn = false; }
            
            gameState.currentPlayer = gameState.currentPlayer === 'player1' ? 'cpu' : 'player1';
            const newPlayer = gameState.players[gameState.currentPlayer];
            newPlayer.gold += GAME_CONFIG.GOLD_PER_TURN;

            if (gameState.currentPlayer === 'player1') {
                gameState.turn++;
                if (gameState.turn > 1 && gameState.turn % GAME_CONFIG.ITEM_SPAWN_RATE === 0) {
					const emptyTiles = [];
					for (let y = 1; y < 7; y++) for (let x = 0; x < 8; x++) if (!gameState.board[y][x].unit && !gameState.board[y][x].item && gameState.board[y][x].terrain !== 'mountain') emptyTiles.push({ x, y });
					if (emptyTiles.length > 0) {
						const { x, y } = emptyTiles[Math.floor(Math.random() * emptyTiles.length)];
						gameState.board[y][x].item = { type: 'gold', amount: GAME_CONFIG.ITEM_GOLD_AMOUNT };
						Logger.add(t('log_item_spawn'), 'system');
					}
				}
            } else {
                setTimeout(() => AI.takeTurn(), 1000);
            }
            Logger.add(t('log_turn_start', { player: t(gameState.currentPlayer) }), 'system');
            clearHighlights(); updateUIElements(); renderGame();
        }

        document.querySelectorAll('.shop-item').forEach(item => {
            item.addEventListener('click', () => {
                if (gameState.currentPlayer !== 'player1' || gameState.gameOver) return;
                const type = item.dataset.unit;
                if (gameState.players.player1.gold < UNIT_STATS[type].cost) return;
                gameState.unitToBuy = type; clearHighlights();
                for (let y = 6; y < 8; y++) for (let x = 0; x < 8; x++) if (!gameState.board[y][x].unit) boardEl.querySelector(`.tile[data-x="${x}"][data-y="${y}"]`)?.classList.add('spawn');
            });
            item.addEventListener('mouseenter', () => {
                const type = item.dataset.unit, unit = UNIT_STATS[type];
                const tooltip = document.getElementById('unit-tooltip');
                tooltip.style.left = `${item.getBoundingClientRect().left - 220}px`;
                tooltip.style.top = `${item.getBoundingClientRect().top}px`;
                tooltip.innerHTML = `<h4>${t(type.toLowerCase())}</h4>
                    <div class="stat-row"><span class="stat-label">${t('hp')}:</span><span class="stat-value">${unit.hp}</span></div>
                    <div class="stat-row"><span class="stat-label">${t('attack')}:</span><span class="stat-value">${unit.attack}</span></div>
                    <div class="stat-row"><span class="stat-label">${t('moveRange')}:</span><span class="stat-value">${unit.moveRange}</span></div>
                    <div class="stat-row"><span class="stat-label">${t('attackRange')}:</span><span class="stat-value">${unit.attackRange}</span></div>
                    <div class="stat-row"><span class="stat-label">${t('cost')}:</span><span class="stat-value">${unit.cost}G</span></div>`;
                tooltip.style.display = 'block';
            });
            item.addEventListener('mouseleave', () => { document.getElementById('unit-tooltip').style.display = 'none'; });
        });
		
        let selectedPlayerFaction = 'human', selectedCpuFaction = 'undead';
        function showModal(id) { document.querySelectorAll('.modal-overlay').forEach(m => m.style.display = 'none'); document.getElementById(id).style.display = 'flex'; updateAllUIText(); }
        document.querySelectorAll('[data-lang]').forEach(b => b.addEventListener('click', (e) => { currentLang = e.target.dataset.lang; showModal('tutorial-modal'); }));
        document.getElementById('start-tutorial-btn').addEventListener('click', () => { gameState.isTutorial = true; showModal('faction-modal'); });
        document.getElementById('skip-tutorial-btn').addEventListener('click', () => { gameState.isTutorial = false; showModal('faction-modal'); });
        document.querySelectorAll('.faction-btn').forEach(b => b.addEventListener('click', (e) => { document.querySelectorAll('.faction-btn').forEach(btn => btn.classList.remove('selected')); e.currentTarget.classList.add('selected'); selectedPlayerFaction = e.currentTarget.dataset.faction; }));
        document.getElementById('confirm-faction-btn').addEventListener('click', () => showModal('difficulty-modal'));
        document.querySelectorAll('.difficulty-btn').forEach(b => b.addEventListener('click', (e) => { gameState.cpuDifficulty = e.target.dataset.difficulty; document.getElementById('difficulty-modal').style.display = 'none'; startGame(); }));
        document.getElementById('restart-btn').addEventListener('click', () => showModal('lang-modal'));

        initBoard(); showModal('lang-modal');
    });
    </script>
</body>
</html>
